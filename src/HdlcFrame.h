#ifndef __HdlcFrame_H
#define __HdlcFrame_H

#include <QByteArray>

#include "HDLC.h"

/*
 *
 *                                       Если «адрес источника» = 0хЕ6, то передается команда,
 *                                       если «адрес источника» = 0хЕ7, то передаётся ответ.
 *                                                                  ▼
 *                                      ┌──────────────────┬──────────────────┬──────────────────┬─────────────┐
 *                                      │ Адрес получателя │  Адрес источника │  Поле управления │  Информация │
 *                                      ├──────────────────┼──────────────────┼──────────────────┼─────────────┤
 *                                      │      0xE6        │  0xE6 или 0xE7   │      0x00        │             │
 *                                      └──────────────────┴──────────────────┴──────────────────┴─────────────┘
 *                                                                            ┬
 *  DA, SA - поле адреса назначения и адреса источника. В зависимости         │
 *  от направления передачи клиент может быть, как источником, так и          │
 *  получателем, также, как и сервер. Адрес клиента всегда 1 байт,            │
 *  адрес сервера может быть 1,2,4 байта.                                     ▼
 * ┌───────────┬─────────────┬─────────┬────────┬───────────────┬─────────┬───────────┬─────────┬────────────┐
 * │    Flag   │    Format   │    DA   │   SA   │    Control    │   HCS   │  Inform.  │   FCS   │    Flag    │
 * ├───────────┼─────────────┼─────────┼────────┼───────────────┼─────────┼───────────┼─────────┼────────────┤
 * │   0x7E    │   16 бит    │1,2 байта│  8 бит │     8 бит     │  16 бит │           │ 16 бит  │    0x7E    │
 * └───────────┴─────────────┴─────────┴────────┴───────────────┴─────────┴───────────┴─────────┴────────────┘
 *                   ▲       HCS - контрольная сумма заголовка. Длина контрольной суммы 2 байта. Контрольная
 *                   │             сумма вычисляется по содержимому полей «Format», «DA», «SA» и «Control».
 *                   │       FCS - контрольная сумма кадра. Вычисляется по содержимому всего кадра, исключая
 *                   │             флаги. При отсутствии информационного поля во фрейме совпадает с контрольной суммой
 *                   │             заголовка и не передается.
 *                   │
 *                   ┴
 *  Поле «Format» - определяет тип фрейма,
 *  наличие сегментации и длину фрейма
 *      ┌──────┬──────┬──────┬──────┬──────┬──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
 *      │  15  │  14  │  13  │  12  │  11  │  10  │  9  │  8  │  7  │  6  │  5  │  4  │  3  │  2  │  1  │  0  │
 *      ├──────┴──────┴──────┴──────┼──────┼──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┤
 *      │      Тип фрейма = 3       │  S   │                     Длина фрейма в байтах                        │
 *      ├──────┬──────┬──────┬──────┼──────┼──────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┤
 *      │   1  │   0  │   1  │   0  │ 1/0  │      │     │     │     │     │     │     │     │     │     │     │
 *      └──────┴──────┴──────┴──────┴──────┴──────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
 *  •  Бит S, установленный в «1», говорит о необходимости принять этот и последующие фреймы, как единый блок.
 *     В последнем фрейме блока бит S должен быть сброшен в «0».
 *  •  Длина фрейма включает в себя все поля, кроме флагов.
 *
 * */

//---------------------------------------------------------------------------//

class HdlcFrame
{
public:
    HdlcFrame(uint8_t size);
    HdlcFrame(uint8_t size, const QByteArray &data);

    QByteArray toData() const;

    void setFinal(bool final);
    bool isFinal() const;

    void setLogicalDevice(uint8_t value);
    uint16_t getLogicalDevice() const;

    void setDeviceid(uint8_t value);
    uint16_t getDeviceId() const;

    void setControl(uint8_t data);
    uint8_t getControl() const;
    

    void setClientId(uint8_t value);
    uint16_t getClientId() const;

    bool isValid() const;

    void setInfo(const QByteArray &info);
    QByteArray getInfo() const;

    hdlc::ControlType type() const;

private:
    bool parseFrameData_i(const QByteArray &data);

private:
    bool    is_valid;
    uint8_t addr_size;
    
    uint16_t format;
    uint8_t  logical_device;
    uint8_t  device_id;
    uint8_t  client_id;
    uint8_t  control;

    QByteArray frame_info;
};

//---------------------------------------------------------------------------//


#endif /*__HdlcFrame_H*/
